<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/paper-material/paper-material.html">
<link rel="import" href="../../../bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="../../../bower_components/polymer/lib/mixins/gesture-event-listeners.html">

<!--
    @author Robin Duda
    Realm chat.
 -->

<dom-module id="spell-bar">
    <link rel="import" href="../../style/theme.css" type="css">
    <link rel="import" href="../../style/style.css" type="css">
    <template>
        <style>
            :host {
                position: absolute;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                width: 326px;
            }

            .spell-bar {
                height: 46px;
                display: flex;
            }

            .spell-icon {
                height: 42px;
                padding-left: 4px;
                padding-right: 4px;
            }

            .cooldown-bar {
                --paper-progress-active-color: #4db6ac;
                --paper-progress-container-color: #4db6ac32;
                width: 42px;
                margin-left: 4px;
                position: absolute;
                top: 40px;
            }

            @keyframes fadein {
                from {
                    opacity: 0;
                }
                to {
                    opacity: 1;
                }
            }

            #casting-progress {
                position: absolute;
                margin-top: 4px;
                top: -36px;
                display: inline;
                width: 100%;
                animation: 0.72s fadein ease 1;
            }

            #casting-progress-bar {
                --paper-progress-active-color: rgba(205, 205, 205, 0.25);
                --paper-progress-container-color: rgba(0, 0, 0, 0.25);
                --paper-progress-height: 24px;
                background-color: #000000;
                width: 100%;
            }

            #casting-progress-title {
                display: block;
                width: 100%;
                text-align: center;
                position: absolute;
                margin-top: -22px;
                font-size: small;
            }

            paper-progress {
                --paper-progress-transition-duration: 0.08s;
                --paper-progress-transition-timing-function: linear;
                --paper-progress-transition-transition-delay: 0s;
            }

            .title {
                font-size: 2.0em;
            }

            .description {
                margin-top: 12px;
                display: block;
                font-size: larger;
            }

            .target {
                color: #00b0ff;
            }

            .cooldown {
                color: #00b0ff;
            }

            .casttime {
                color: #00b0ff;
            }

            .spell-info {
                width: 246px;
            }

            .info-table {
                margin-top: 12px;
                width: 100%;
            }

            .charges {
                position: absolute;
                font-size: 0.8em;
                left: 22px;
                top: 28px;
                display: block;
                text-shadow: 1px 1px #000;
            }

            @media (max-width: 1268px) {
                :host {
                    right: 48px;
                }
            }

            .unavailable {
                opacity: 0.5;
            }

            .spell-button {
                position: relative;
            }

            .spell-table-headers {
                font-size: 11px;
            }

            .spell-table-values {
                text-align: center;
                font-size: 12px;
            }

        </style>

        <paper-material elevation="3" class="spell-bar interface-box noselect">
            <template is="dom-repeat" items="[[_list(spells, character)]]" as="spell">
                <div on-click="_onCast" class="spell-button">
                    <img class$="spell-icon {{_available(spell.id, charges.*, cooldown.*)}}"
                         src="[[realm.resources]]/gui/spell/[[spell.id]].svg">
                    <paper-tooltip class="spell-info" animation-delay="0" position="top">
                        <span class="title">[[spell.name]]</span>

                        <table class="info-table">
                            <tr class="spell-table-headers">
                                <th>Cooldown</th>
                                <th>Cast</th>
                                <th>Target</th>
                            </tr>
                            <tr class="spell-table-values">
                                <td class="cooldown">[[spell.cooldown]]s</td>
                                <td class="casttime">[[spell.casttime]]s</td>
                                <td class="target">[[spell.target]]</td>
                            </tr>
                        </table>

                        <span class="description">{{_description(spell, character)}}</span>

                    </paper-tooltip>
                    <template is="dom-if" if="{{_chargeable(spell, character)}}">
                        <span class="charges">[[_charges(spell, charges.*)]]</span>
                    </template>
                    <template is="dom-if" if="{{!_chargeable(spell, character)}}">
                        <paper-progress id="cd-bar-[[spell.id]]" class="cooldown-bar transiting" min="0"
                                        max="100" value="0"></paper-progress>
                    </template>
                </div>
            </template>

        </paper-material>

        <template is="dom-if" if="[[casting]]">
            <div id="casting-progress">
                <paper-progress id="casting-progress-bar" class="casting-bar transiting" min="0" max="100"
                                value="0">
                </paper-progress>
                <span id="casting-progress-title">[[_name(spellId)]]</span>
            </div>
        </template>

    </template>
    <script>
        class SpellBar extends Polymer.GestureEventListeners(Polymer.Element) {

            static get is() {
                return 'spell-bar';
            }

            static get properties() {
                return {
                    spells: {
                        type: Array,
                        notify: true,
                        observe: true,
                        value: []
                    }
                }
            }

            constructor() {
                super();
                this.hotkeys = ['q', 'e', 'r', 'f', 'x', 'c', 'v'];
                this.spells = [];
                this.charges = {};
                this.cooldown = {};
                this.target = {};
                this.character = {
                    spells: {
                        learned: []
                    }
                };
            }

            ready() {
                super.ready();

                application.onCharacterLoaded(player => {
                    this.set('character', player);
                });

                application.onRealmLoaded(realm => {
                    this.realm = realm;
                    this.spells = realm.spells;
                });

                application.onGameLoaded((game) => {
                    input.onKeysListener({
                        down: (key) => {
                            let spellId = this.character.spells.learned[this.hotkeys.indexOf(key)];
                            this._cast(this._getSpellById(spellId));
                        }
                    }, this.hotkeys);

                    game.subscribe('character-target', character => {
                        this.target = character;
                    });

                    game.spells.onCharge((spellId, charges) => {
                        this.set(`charges.${spellId}`, charges);
                    });

                    game.spells.onCooldown((spell, ms) => {
                        // chargeable spells don't show any cooldown information.
                        if (!this._chargeable(this._getSpellById(spell))) {
                            this.set(`cooldown.${spell}`, true);
                            let bar = this.shadowRoot.querySelector(`#cd-bar-${spell}`);
                            bar.style.visibility = 'visible';

                            bar.style.setProperty('--paper-progress-transition-duration', '0s');
                            bar.value = 0;

                            setTimeout(() => {
                                bar.style.setProperty(
                                    '--paper-progress-transition-duration',
                                    (ms / 1000).toFixed(1) + 's'
                                );
                                setTimeout(() => {
                                    bar.value = 100;
                                }, 96);
                            }, 96);

                            setTimeout(() => {
                                this.set(`cooldown.${spell}`, false);
                                bar.style.visibility = 'hidden';
                                bar.style.setProperty('--paper-progress-transition-duration', '0s');
                                bar.value = 0;
                            }, ms);
                        }
                    });

                    game.spells.onGCD((ms) => {
                        //console.log(`global gcd for ${ms}ms.`);
                    });

                    setTimeout(() => {
                        game.spells.emit();
                    }, 64);
                });
            }

            _available(spellId) {
                let spell = this._getSpellById(spellId);

                if (this._chargeable(spell)) {
                    return (this.charges[spellId] > 0) ? '' : 'unavailable';
                } else {
                    return (!this.cooldown[spellId]) ? '' : 'unavailable';
                }
            }

            _charges(spell) {
                return this.charges[spell.id] || 0;
            }

            _name(spellId) {
                let spell = this._getSpellById(spellId);
                if (spell) {
                    return spell.name;
                } else {
                    return "";
                }
            }

            _list() {
                let list = [];
                for (let spell of this.character.spells.learned) {
                    list.push(this._getSpellById(spell));
                }
                return list;
            }

            _chargeable(spell) {
                return spell.charges > 0;
            }

            _getSpellById(spellId) {
                return game.spells.getById(spellId);
            }

            _description(spell) {
                return eval('`' + spell.description + '`');
            }

            _onCast(event) {
                this._cast(event.model.spell);
            }

            _cast(spell) {
                if (this.casting) {
                    return;
                }

                game.spells.cast((casted) => {
                    if (casted.result === 'CASTING') {
                        this.casting = true;
                        this.spellId = casted.spellId;

                        Polymer.RenderStatus.afterNextRender(this, () => {
                            let progress = this.shadowRoot.querySelector('#casting-progress-bar');

                            progress.style.visibility = 'visible';
                            progress.value = 100;
                            progress.style.setProperty(
                                '--paper-progress-transition-duration',
                                spell.casttime + 's'
                            );

                            setTimeout(() => {
                                this.casting = false;
                                progress.style.visibility = 'hidden';
                                progress.value = 0;
                            }, spell.casttime * 1000);
                        });
                    } else {
                        let spell = game.spells.getById(casted.spellId);

                        if (casted.result === 'UNABLE') {
                            application.publish('notification', `unable to cast ${spell.name}.`);
                        }

                        if (casted.result === 'COOLDOWN') {
                            application.publish('notification', `${spell.name} is on cooldown.`);
                        }

                        if (casted.result === 'UNKNOWN_SPELL') {
                            application.publish('notification', `unknown spell ${casted.spellId}.`);
                        }
                    }
                }, spell.id, {targetId: this.target.id});
            }

            _learned(spell) {
                return this.character.spells.learned.indexOf(spell.id) >= 0;
            }
        }

        window.customElements.define(SpellBar.is, SpellBar);
    </script>
</dom-module>
