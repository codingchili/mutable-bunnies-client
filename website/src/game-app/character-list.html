<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-material/paper-material.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/paper-ripple/paper-ripple.html">
<link rel="import" href="../../bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="../../bower_components/paper-spinner/paper-spinner-lite.html">
<link rel="import" href="../../bower_components/neon-animation/animations/scale-up-animation.html">
<link rel="import" href="../../bower_components/neon-animation/animations/fade-out-animation.html">
<link rel="import" href="../../bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="character-create.html">
<link rel="import" href="mega-loader.html">


<!--
    @author Robin Duda
    Polymer element for a simple admin-panel using iron-pages.
 -->

<dom-module id="character-list">
    <link rel="import" href="../style/theme.css" type="css">
    <link rel="import" href="../style/style.css" type="css">
    <template>
        <style>
            :host {
                display: block;
                padding-top: 128px;
            }

            .container {
                display: block;
                width: 582px;
                margin-bottom: 32px;
                /* super important property that fixes a 1px jump on hover. */
                backface-visibility: hidden;
            }

            .character {
                cursor: pointer;
                width: 128px;
                height: 154px;
                margin-left: 16px;
                margin-right: 16px;
                margin-bottom: 48px;
                float: left;
            }

            .realm-title {
                padding-top: 20px;
                display: block;
                text-align: center;
                width: 100%;
                height: 64px;
            }

            .character-name {
                font-size: smaller;
                bottom: 4px;
                width: 100%;
                text-align: center;
            }

            .character-list-box {
                width: 480px;
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                margin: auto;
            }

            .character-create {
                width: 100%;
            }

            .tooltip {
                width: 148px;
                text-align: center;
                margin-top: -6px;
            }

            .tooltip-text {
                font-size: 14px;
            }

            .character-remove {
                z-index: 0;
                float: right;
                margin-bottom: -24px;
            }

            @media (max-width: 728px) {
                :host {
                    padding-top: 36px;
                }

                .character {
                    margin-left: 12px;
                    margin-right: 12px;
                    margin-bottom: 12px;
                }

                .container {
                    width: 100%;
                    margin-bottom: 20px;
                }

                .character-list-box {
                    width: 100%;
                }
            }
        </style>

        <template is="dom-if" if="[[!create]]">
            <paper-material class="container center-box noselect" elevation="3">
                <div class="realm-title">
                    <h4 style="display: inline-block">{{realm.node}}</h4>
                    <iron-icon on-down="realmlist"
                               icon="icons:reply"></iron-icon>
                </div>

                <mega-loader text="[[status]]" enabled="[[!loaded]]"></mega-loader>

                <div class="character-list-box" hidden$="[[!loaded]]">
                    <template is="dom-repeat" items="[[realm.characters]]" as="character">
                        <paper-material elevation="2" class="character" on-tap="select">
                            <paper-ripple></paper-ripple>
                            <paper-tooltip animation-delay="0" class="tooltip">
                                <span class="tooltip-text">{{_className(character.classId)}} {{_level(character.stats)}}</span>
                            </paper-tooltip>
                            <iron-icon on-tap="removeCharacter"
                                       icon="icons:close" class="character-remove"></iron-icon>
                            <img src="[[realm.resources]]/gui/class/[[character.classId]].svg"
                                 class="class-image">

                            <div class="character-name">{{character.name}}</div>
                        </paper-material>
                    </template>

                    <paper-button on-tap="showCreate">Create</paper-button>
                </div>
            </paper-material>
        </template>

        <character-create id="creator" hidden="[[list]]" class="character-create"></character-create>
        <paper-toast class="fit-bottom" id="toast" text="[[toastText]]"></paper-toast>
    </template>
    <script>
        class CharacterList extends Polymer.GestureEventListeners(Polymer.Element) {

            static get is() {
                return 'character-list';
            }

            ready() {
                super.ready();

                this.list = true;

                application.onRealmSelect((realm) => {
                    this.set('realm', realm);
                    this.server = new RealmServer(this.realm);

                    this.$.creator.setServer(this.server);
                    this.$.creator.setToaster(this.showToast.bind(this));

                    this.showCharacters();
                    this.realmtoken();
                });

                application.onLogout(() => {
                    if (this.server) {
                        this.server.close();
                    }
                });

                application.subscribe('cancel-create', () => {
                    if (this.realm.characters.length > 0) {
                        this.showCharacters();
                    } else {
                        this.realmlist();
                    }
                });

                application.subscribe('character-create', () => {
                    this.showCharacters();
                    this.loadCharacters();
                });

            }

            _level(stats) {
                if (stats.level) {
                    return `Lv. ${stats.level}`;
                } else {
                    return '';
                }
            }

            realmtoken() {
                this.showLoading('Authenticating..');
                new RealmRegistry().realmtoken({
                    accepted: (data) => {
                        this.realm.token = data.token;
                        this.loadRealmInfo();
                    },
                    error: (err) => {
                        application.error(err.message);
                    }
                }, this.realm.node);
            }

            loadRealmInfo() {
                this.showLoading("Logging in..");
                this.server.connect({
                    accepted: (realm) => {
                        this.realm = realm;
                        this.loadMetadata();
                    },
                    error: (err) => {
                        application.error(err.message);
                    }
                });
            }

            _className(classId) {
                return this.realm.classes.get(classId).name;
            }

            loadMetadata() {
                this.showLoading("Loading metadata..");
                let count = 3;
                let latch = () => {
                    count--;
                    if (count === 0) {
                        this.loadCharacters();
                        application.realmLoaded(this.realm);
                    }
                };
                let metadataError = (err) => {
                    application.error(err.message);
                };

                this.server.spellinfo({
                    accepted: (data) => {
                        this.realm.spells = data.collection;
                        latch();
                    },
                    error: metadataError
                });
                this.server.classinfo({
                    accepted: (data) => {
                        this.realm.classes = data.collection;
                        this.realm.classes.get = (id) => {
                            for (let playableClass of this.realm.classes) {
                                if (playableClass.id === id) {
                                    return playableClass;
                                }
                            }
                            throw Error(`Class ${id} not found in realm`);
                        };
                        latch();
                    },
                    error: metadataError
                });
                this.server.afflictioninfo({
                    accepted: (data) => {
                        this.realm.afflictions = data.collection;
                        latch();
                    },
                    error: metadataError
                });
            }

            loadCharacters() {
                this.set('realm.characters', []);
                this.showLoading('Loading characters..');
                this.server.characterlist({
                    accepted: (data) => {
                        Object.assign(this.realm, data.realm);

                        this.hideLoading();
                        this.set('realm.characters', data.characters);

                        if (data.characters.length > 0) {
                            this.showCharacters();
                        } else {
                            this.showCreate();
                        }

                        if (application.development.selectFirstCharacter) {
                            this.select({
                                model: {
                                    character: data.characters[0]
                                }
                            })
                        }
                    },
                    unauthorized: (data) => {
                        application.error('The authentication server rejected the realm token when listing characters.');
                    }
                });
            }

            removeCharacter(e) {
                e.stopPropagation();
                this.set('realm.characters', []);
                this.showLoading('Removing character..');

                this.server.remove({
                    accepted: () => {
                        this.showToast(`${e.model.character.name} is now a goner.`);
                        this.loadCharacters();
                    },
                    error: () => {
                        application.error('Failed to connect to the authentication server to delete a character.');
                    }
                }, e.model.character.name);
            }

            showLoading(status) {
                this.set('status', status);
                this.set('loaded', false);
            }

            hideLoading() {
                this.set('loaded', true);
            }

            showCreate() {
                this.set('list', false);
                this.set('create', true);
            }

            showCharacters() {
                this.set('list', true);
                this.set('create', false);
            }

            realmlist() {
                this.server.close();
                application.showRealms();
            }

            showToast(text) {
                this.toastText = text;
                this.$.toast.open();
            }

            select(e) {
                let character = e.model.character;

                if (this.realm.availableClasses.indexOf(e.model.character.classId) >= 0) {
                    application.selectCharacter({
                        server: this.server,
                        realm: this.realm,
                        character: character
                    });

                    for (let playerClass of this.realm.classes) {
                        if (playerClass.id === character.classId) {
                            document.body.style.setProperty('--player-class-theme', playerClass.theme);
                        }
                    }
                } else {
                    this.showToast("Sorry this class has been temporarily disabled.");
                }
            }
        }

        window.customElements.define(CharacterList.is, CharacterList);
    </script>
</dom-module>